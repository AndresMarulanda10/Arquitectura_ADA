# Arquitectura Prueba Técnica ADA, Carlos Andres Marulanda Rojas
## Introducción
En esta arquitectura se presenta la arquitectura de referencia integral para la migración estratégica y escalable de una aplicación de comercio electrónico monolítica Java hacia una arquitectura distribuida basada en microservicios. La propuesta aborda sistemáticamente las diferencias críticas identificadas en la plataforma actual como limitaciones de escalabilidad horizontal, acoplamiento excesivo entre componentes y ciclos prolongados de despliegue que impactan la capacidad de respuesta del negocio frente a cambios del mercado. Se diseñó empleando principios de Domain Driven Design (DDD) para identificar límites de contexto acotados que permitirán una descomposición funcional coherente del sistema.
Adicionalmente para mantener un estándar regulatorio y de seguridad, se contempló la implementación de PCI-DSS para procesamiento seguro de transacciones y datos de tarjetas de pago, protección de datos frente a conformidad con GDPR y CCPA para el manejo de datos personales y derechos de usuario y por último un estándar de API RESTful con adhesión a las especificaciones RFC 7231 y algunas prácticas HATEOAS para el diseño de APIs predecibles, mantenibles y autoexplicativas.
## Arquitectura
La arquitectura propuesta implementa un acosistema de microservicios siguiendo el paradigma de Domain Driven Design para descomponer estratégicamente el monolito actual en unidades funcionales autónomas. Esta descomposición se basa en un análisis de los dominios de negocio, identificando Bounded Context claramente delimitados que permiten maximizar la cohesión interna mientras se minimiza el acoplamiento entre servicios. El enfoque arquitectónico favorece la evolución independiente y el despliegue autónomo de cada componente, potenciando la agilidad organizacional y la capacidad de respuesta ante cambios en el mercado. Esta arquitectura tiene como pilar o pilares el desacoplamiento mediante boundaries, microservicios autónomos con bases de datos dedicadas siguiendo el patrón Database-per-Service, API Gateway centralizado con una implementación de Kong como punto único de entrada, proporcionando enrutamiento, seguridad, control de tráfico y observabilidad, comunicación híbrida estratégica con protocolos síncronos para operaciones que requieren respuesta inmediata y asíncronos para flujos de trabajo con una duración extensa y adicionalmente pero no menos importante consistencia eventual para implementar el patrón Saga el cuál orquestará transacciones distribuidas complejas, garantizando la coherencia del sistema mediante mecanismos de compensación.
Esta arquitectura destruye el dominio monolítico en servicios independientes basados en capacidades de negocio claramente definidas. Esta descomposición se ha realizado siguiendo principios de DDD, identificando subdominios y delimitando Bounded Contexts que permiten mantener la integridad y coherencia conceptual de cada componente. Tomando en cuenta los servicios principales identificados para la migración como el servicio de producto con gestión integral del catálogo de productos y su inventario, administración de metadatos de productos, gestión de inventario, políticas de precios, API RESTful para operaciones CRUD sobre productos y consultas de inventario, eventos duplicados, estructura normalizada para productos, categorías, variantes, precios e inventario, el servicio de usuarios con gestión de identidad, autorización, registro, gestión de perfiles, permisos, OAuth 2.0, estructura para usuarios y credenciales, y el servicio de órdenes, una orquestación del ciclo de vida completo de las ordenes, creación, procesamiento, validación, coordinación, estructura, ítems, estados, cambios y demás.
## Identificación de Servicios
La migración hacia una arquitectura de microservicios para la plataforma de comercio electrónico requiere un enfoque metódico basado en los principios de Domain Driven Design. Con tres dominios fundamentales que constituyen la primera fase de la transformación arquitectónica.
Product Service asume la responsabilidad de la gestión integral del catálogo e inventario, este componente encapsula toda la lógica relacionada con los productos, incluyendo metadatos, precios y disponibilidad. También expone sus capacidades mediante una API RESTful que permite operaciones CRUD completas. La naturaleza del dominio de productos requiere un enfoque orientado a eventos, publicando notificaciones clave como ProductCreated, ProductUpdated e InventoryChanged para mantener la coherencia del sistema.
También, el User Service centraliza todos los aspectos relacionados con la identidad digital de los usuarios, este servicio gestiona el ciclo de vida completo de las cuentas como registro, autenticación, administración de perfiles y definición de permisos. También incorpora estándares de industria como OAuth 2.0 y OpenID Connect para proporcionar capacidades de autenticación federada. Algo crítico de este servicio es el almacenamiento seguro de credenciales, implementando prácticas criptográficas avanzadas.
El Order Service representa el núcleo transaccional del sistema, orquestando el ciclo completo de las órdenes desde su creación hasta su cumplimiento. Este servicio coordina transacciones distribuidas complejas que involucran múltiples dominios, manteniendo la integridad del estado de las órdenes y los pagos asociados. Su diseño considera la naturaleza crítica de las operaciones comerciales, implementando mecanismos robustos de validación y seguimiento.
## Patrones de Comunicación
Un modelo híbrido de comunicación que optimiza los patrones de interacción entre servicios según los requisitos específicos de cada escenario. Este enfoque reconoce que no existe una solución universal para todos los casos de uso.
La comunicación síncrona se implementa mediante REST y gRPC, reservándose para operaciones que demandan validación inmediata, como la verificación de inventario o la consulta de detalles de usuario. Las interfaces REST se utilizan preferentemente para APIs externas por su universalidad, mientras que gRPC proporciona un mecanismo más eficiente para la comunicación interna entre servicios. Como mecanismo de resiliencia, se implementa el patrón Circuit Breaker, proporcionando que se degrade de manera elegante ante fallos.
La comunicación asíncrona basada en eventos se implementa para flujos de trabajo de larga duración y notificaciones de cambio de estado. Kafka se establece como el message broker central, proporcionando garantías de entrega y ordenamiento. El sistema emplea patrones específicos como Event Notification para comunicaciones livianas y Event-Carried State Transfer para reducir acoplamientos sincrónicos.
Para el caso específico de "crear una nueva orden", se adopta un enfoque híbrido, la validación inicial de usuario e inventario se realiza sincrónicamente para garantizar feedback inmediato, mientras que el procesamiento de pago y confirmación posterior continúa asíncronamente. Este flujo complejo se orquesta mediante el patrón Saga.
## Estrategia de Datos
La gestión de datos adopta el patrón Database-per-Service, otorgando a cada microservicio su propia instancia de PostgreSQL. Este enfoque proporciona autonomía completa en la evolución del esquema de datos, permitiendo a cada equipo optimizar su persistencia según requisitos específicos. El Product Service implementa extensiones para búsqueda por similitud, el Order Service utiliza particionamiento por rango para optimizar consultas históricas, y el User Service incorpora extensiones para operaciones criptográficas.
La consistencia entre servicios representa un desafío inherente a las arquitecturas distribuidas. Para abordarlo, se implementa el patrón Saga utilizando Temporal.io como orquestador de transacciones distribuidas. Se complementa con operaciones de compensación que garantizan consistencia eventual ante fallos, para optimizar consultas que atraviesan múltiples dominios, se implementan vistas materializadas que proporcionan representaciones desnormalizadas de datos compuestos.
## Componentes Transversales
La arquitectura incorpora componentes transversales que proporcionan capacidades fundamentales para todo el ecosistema. El API Gateway implementado con Kong actúa como punto único de entrada para todas las solicitudes externas, proporcionando enrutamiento inteligente, autenticación centralizada y capacidades avanzadas como rate limiting y transformación de payloads.
El subsistema de autorización y autenticación implementa OAuth 2.0/OIDC para autenticación federada, utilizando tokens JWT con claims personalizados para autorización. El control de acceso se gestiona mediante RBAC granular, que permite definiciones precisas de permisos a nivel de recurso y operación.
La observabilidad constituye un pilar fundamental de la arquitectura, implementando los tres pilares esenciales propuestos, métricas con Prometheus y Grafana, logs centralizados mediante Elastic Stack, y trazas distribuidas con Jaeger. Capacidades que se complementan con un sistema de alerting proactivo basado en SLOs claramente definidos.
La infraestructura subyacente se implementa sobre Kubernetes, proporcionando alta disponibilidad mediante una estrategia multi-región y multi-AZ. Todo el aprovisionamiento y configuración se realiza mediante prácticas de Infrastructure as Code, garantizando reproducibilidad y trazabilidad en todos los entornos.
## Diagrama de Arquitectura
El diagrama de componentes se encuentra en [architecture.puml](https://github.com/AndresMarulanda10/Arquitectura_ADA/blob/main/architecture.puml), ilustrando de manera detallada los servicios propuestos y sus patrones de interacción principales.
## Conclusión
La arquitectura propuesta aborda los problemas de la plataforma monolítica actual mediante un enfoque sistemático de desacoplamiento basado en Bounded Contexts de Domain Driven Design. La estrategia híbrida de comunicación optimiza cada interacción según sus requisitos específicos, mientras que el patrón Database-per-Service proporciona la autonomía necesaria para la evolución independiente de cada dominio.
Los componentes transversales implementan prácticas para seguridad y observabilidad, garantizando que la plataforma cumpla con requisitos no funcionales críticos. Esta arquitectura permitirá reducir el tiempo de despliegue, incrementar la capacidad de procesamiento los niveles actuales, mejorar la disponibilidad del sistema y habilitar la evolución independiente de componentes según necesidades específicas de negocio.
